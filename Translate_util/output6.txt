Algorithm 2 describes the CEI function that recursively traverses a condition tree of an applet, and calculates an appropriate interval for the condition tree. The condition C is either a leaf node or an internal node. If C is a leaf node, the condition C has only one sensor value si and its comparison target value xi. If the difference between si and xi is large enough, the CEI function can increase its evaluation interval until the predicted sensor value changes more than the difference. Thus, the CEI function finds the maximum evaluation interval that satisfies psi(s < jxi??sij jsij j t) larger than 1 ?? e. Here, psi(s < jxi??sij jsij j t) means the probability that si does not reach xi after a given time interval t. The probability should be larger than userdefined success ratio (1 ?? e). If the CEI function cannot find any appropriate interval or the interval is smaller than the relative deadline D, the function just returns the deadline D, which is the worst-case interval. If C is an internal node, CEI first recursively calculates the condition evaluation intervals of both subtrees (Cleft andCright). Then, if two subtrees are linked by && operator, the CEI function returns the maximum interval between two intervals because the condition C will be true only when both subtrees are true. Here, if one of the sub-condition is already true, the CEI function uses the interval of the other subcondition. If two sub-conditions are true , that is, C is true, then the applet is already triggered and the applet manager excludes this applet from the sensor polling scheduler. If two subtrees are linked with jj operator, it takes the minimum interval between the two intervals that CEI calculates with an adjusted miss ratio (1 ?? p 1 ?? e), because the condition C will be true if at least one of the subtrees is true.Algorithm 3 describes the SPI function that finds the minimum polling interval of a sensor si among its relevant evaluation intervals. Since the evaluation intervals are the maximum intervals that each applet can meet its constraints, the polling intervals of the related sensors cannot exceed the evaluation intervals. Thus, the SPI function finds the minimum interval for a senor among the maximum evaluation intervals of its relevant applets. Here, if a sensor si is not used in any of applets with updated evaluation intervals, the SPI function sets the polling interval of si as Intmax, so the sensor polling scheduler leaves its next polling schedule unchanged. Theorem 1 (Deadline Guarantee). Given a misspeculation ratio e, the algorithm finds Isi (i = 1; :::;N) that meets the following condition. For every applet aj (j = 1; :::;M), there exists a sensor polling of a sensor value si that is used in aj and satisfies p(I(k) si = t(k+1) si ?? t(k) si > Daj )  e where t(k) si < tEa j < t(k+1) si . Proof. We will prove by induction that for any trigger condition C of an arbitrary applet aj , there exists si that is used in C and satisfies p(I(k) si = t(k+1) si ?? t(k) si > Daj )  e (1) where t(k) si < tEa j < t(k+1) si . Let jCj be the number of sub-conditions in C. Base Case: When jCj = 1, C = Leaf(si ; cop; x) 每 Case I(k) si < Daj : This case is not possible because of lines 3 and 4 in Algorithm 2. 每 Case I(k) si = Daj : p(I(k) si > Daj ) = 0 每 Case I(k) si > Daj : We will prove this by contradiction. Let＊s assume that p(I(k) si = t(k+1) si ?? t(k) si > Daj ) > e In order for an event to occur within a time period I(k) si , si should be larger than jxi??si j jsi j . psi(si  jxi ?? si j jsi j j I(k) si ) > e However, from line 2 of Algorithm 2, psi(si < jxi ?? si j jsi j j I(k) si )  1 ?? e psi(si  jxi ?? si j jsi j j I(k) si ) < e This is contradictory to the assumption. Therefore, p(I(k) si = t(k+1) si ?? t(k) si > Daj )  e Induction Case: Induction Hypothesis:If the statement (1) is true for C with jCj  n, the statement (1) will be true for C which jCj is n + 1. For C0 = Internal(C0left; lop;C0right) which jC0j is n + 1, C0left and C0right satisfy the statement (1) because jC0leftj  n and jC0rightj  n. 每 Case loq = &&: pl(I(kl) sl = t(kl+1) sl ?? t(kl) sl > Daj )  e pr(I(kr) sr = t(kr+1) sr ?? t(kr) sr > Daj )  e There exist four cases. 1) eval(C0left) = true ^ eval(C0right) = true Since C is true, this applet is already triggered and the applet manager excludes this applet from the sensor polling scheduler. 2) eval(C0left) = true ^ eval(C0right) 6= true From line 11 of Algorithm 2, IC0 = I(kr) sr = t(kr+1) sr ?? t(kr) sr p(IC0 > Daj ) = p(I(kr) 