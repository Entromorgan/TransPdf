sr > Daj ) Since eval(C0left) can be false at t(kr+1) sr , C0 will less likely occur than C0right. p(I(kr) sr > Daj )  pr(I(kr) sr > Daj )  e Thus, p(IC0 > Daj )  e3) eval(C0left) 6= true ^ eval(C0right) = true We can complete this case using the same argument as we used for the case 2). 4) eval(C0left) 6= true ^ eval(C0right) 6= true From line 15 of Algorithm 2, IC0 = max(I(kl) sl ; I(kr) sr ) Without loss of generality, assume I(kl) sl  I(kr) sr IC0 = I(kl) sl = t(kl+1) sl ?? t(kl) sl p(IC0 > Daj ) = p(I(kl) sl > Daj ) Since eval(C0right) can be false at t(kl+1) sl , C0 will less likely occur than C0left. p(I(kl) sl > Daj )  pl(I(kl) sl > Daj )  e Thus, p(IC0 > Daj )  e ¨C Case loq = jj: pl(I(kl) sl = t(kl+1) sl ?? t(kl) sl > Daj )  1 ?? p 1 ?? e pr(I(kr) sr = t(kr+1) sr ?? t(kr) sr > Daj )  1 ?? p 1 ?? e From line 19 of Algorithm 2, IC0 = min(I(kl) sl ; I(kr) sr ) Without loss of generality, assume I(kl) sl  I(kr) sr IC0 = I(kl) sl Since I(kl) sl  I(kr) sr , pr(I(kl) sl > Daj )  pr(I(kr) sr > Daj )  1 ?? p 1 ?? e p(I(kl) sl > Daj ) = pl(I(kl) sl > Daj ) + pr(I(kl) sl > Daj ) ?? pl(I(kl) sl > Daj )  pr(I(kl) sl > Daj ) = 1 ?? (1 ?? pl(I(kl) sl > Daj ))  (1 ?? pr(I(kl) sl > Daj ))  1 ?? (1 ?? pl(I(kl) sl > Daj ))  (1 ?? pr(I(kr) sr > Daj ))  1 ?? f1 ?? (1 ?? p 1 ?? e)g  f1 ?? (1 ?? p 1 ?? e)g =e Since the induction hypothesis holds for both logical operators, the statement (1) holds for C0 which jC0j is n + 1. Since both the base and the induction cases are true, by mathematical induction, the statement (1) holds for all the trigger conditions C of an arbitrary applet aj . V. EVALUATION A. Methodology To show that RT-IFTTT effectively schedules data polling, this work simulates the RT-IFTTT system and compares its polling scheduling algorithm with the following three baseline algorithms in the evaluation.  Optimistic Fixed Interval (Fix-Opt): A server polls data from all the sensors every 15 minutes. The 15-minute interval is chosen with reference to the commodity IoT frameworks [1]. Since the algorithm sends requests for data sporadically, the algorithm is highly likely to miss an event with a short relative deadline.  Conservative Fixed Interval (Fix-Con): A server polls data from all the sensors every tcon, where tcon is the minimum relative deadline of all the applets. The algorithm rarely misses deadline, but requires lots of communication.  Random Interval (Random): A server polls data from all the sensors with random intervals. The intervals are randomly selected between the minimum relative deadline and 15 minutes. The above three scheduling algorithms check all the applet conditions at every polling time and trigger appropriate actions if an event occurrence is detected. The major difference between our algorithm in the RT-IFTTT framework and the baseline algorithms is that our algorithm dynamically determines polling intervals considering the probabilities of trigger conditions. To simulate the four algorithms with realistic data, this work installs 10 physical sensors that consist of 2 sets of temperature, humidity, UV Index, ambient light, and pressure sensors, and then collects data from the sensors for 10 days. This work uses the data in the simulation after removing noises of the collected data using a low-pass filter. To differentiate evaluation data from training data, this work divides the collected data into two parts. The RT-IFTTT framework generates the sensor value prediction model using one part of the data, and evaluates the polling scheduling algorithm using the other part of the data. Using the value prediction model, the RT-IFTTT framework calculates probabilities of sensor value gradients over specific time gradient as described in Section III-C. Note that the performance of the value prediction model hugely affects the performance of our algorithm, and the RT-IFTTT framework can use other sensor value prediction models instead of our value prediction model.B. Single-applet Results Figure 8 compares the sensor polling timings of RT-IFTTT with three baseline algorithms (Fix-Opt, Fix-Con, and Random) for one applet. The Fix-Opt and Fix-Con algorithms periodically poll a sensor every 15 minutes and 30 seconds respectively. The random interval algorithm polls the sensor with random intervals. As a result, the Fix-Opt and random baseline algorithms miss the event deadline. The Fix-Con algorithm meets the deadline, but it polls the sensor frequently even when the sensor value is far from the threshold value of the event, causing more battery consumption of the sensor. Unlike the three baseline algorithms, RT-IFTTT dynamically 