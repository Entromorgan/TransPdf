analyze structures of trigger conditions, and determine the order of sensor polling. Here, the algorithms assume that the freshness periods of each sensor data are given as a fixed value. However, as Fig. 2 illustrates, sensing values from different sensors have different characteristics even though they are the same type of sensors. For example, indoor sensors generate more stable temperature, humidity, and illuminance data than outdoor sensors, so indoor sensors can have longer freshness period. Moreover, the sensing values have repeated patterns, so predicting the range of sensor values after minutes or tens of minutes is possible. If the current sensing value is different enough from the trigger conditions, an IoT framework can increase the freshness period of the data. To maximize sensor polling intervals and minimize battery power consumption of sensors, this work dynamically calculates the freshness period of each sensor reflecting the sensing value history, the current sensing value, and its related trigger conditions. To fully support real-time execution of applets while minimizing battery power consumption of sensors with an appropriate sensor polling interval, this work proposes RT-IFTTT that consists of the RT-IFTTT language and its framework.The RT-IFTTT language extends the existing IFTTT rules, and allows users to describe their applets with real-time constraints. Fig. 3 illustrates the overall syntax of the RTIFTTT language. The RT-IFTTT syntax largely consists of three parts such as trigger conditions, actions and real-time constraints. Like the IFTTT syntax, the trigger conditions lead the actions in an applet. The conditions can recursively consist of && or jj combinations of multiple conditions. Each condition consists of a sensing value, a target value and a relational operator. Here, since this paper focuses on finding an efficient polling intervals of sensors that measure continuous values, to simplify the interval finding problem, the RT-IFTTT syntax only allows integers or real numbers for the sensing and target values. Like the conditions, actions can consist of a series of actions, and each action describes an operation of an actuator. Unlike the IFTTT syntax, RT-IFTTT has real-time constraints in its syntax. The constraints describe the deadline of the applet as D and its maximum deadline miss ratio as e. If an applet should always meet its deadline, users can describe the constraints without its miss ratio. If an applet has its maximum miss ratio as e, the RT-IFTTT framework can aggressively defer its sensor polling time, saving battery power of connected sensors. Fig. 4 shows example applets written in the RT-IFTTT language for the Smart Home service in Fig. 1. In the example, there exist three sensors such as a thermometer, a hydrometer and a light meter, and three actuators such as a window, a blind and a bulb. The 5 example applets execute 5 home automation services such as ventilating a room, closing a blind, turning on and off a bulb and closing a window if the sensing values satisfy their trigger conditions. For example, if its temperature and illuminance values are higher than 25 and 25,000, the App_vent applet ventilates the room by opening its window and blind within 300 seconds. The App_day applet defines its constraints without a miss ratio, indicating a firm deadline. The RT-IFTTT compiler analyzes the applets and extracts their trigger conditions, actions and real-time constraints like the first 4 columns of the applet manager table in Fig. 5. The RT-IFTTT framework executes given RT-IFTTT applets respecting their real-time constraints. Fig. 5 illustrates the overall structure of the RT-IFTTT framework. The framework consists of an applet manager, a sensor polling scheduler, a sensor manager and an actuator manager. Applet manager analyzes prerequisite relations among applets and manages current states of applets. If an applet A always triggers its action before another applet B, A is a prerequisite of B. Since the applet cannot be triggered before its prerequisites, if at least one of the prerequisites is not yet triggered, the RT-IFTTT framework can exclude the applet from the scheduling candidates, and reduce the scheduling overheads. For the example of Fig. 5, App_night is a prerequisite of App_rainy because of their comparison operators and target values for L. Since App_night is not yet triggered, the applet manager classifies App_rainy as an inactive applet, and excludes App_rainy from the scheduling candidates. Here, App_vent and App_blind are active because their prerequisite, App_day is already 