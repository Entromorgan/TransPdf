previous polling, the framework conservatively considers the previous polling time point t(k) si as the event occurrence time point tEa j , and calculate the conservative response time RC aj by Raj  RC aj = tAa j ?? t(k) si  Daj To simplify the problem and focus on finding the efficient sensor polling intervals, this work assumes that the time required to complete the action after sensor polling (tAa j ??t(k+1) si ) is fixed and already reflected into the deadline. Therefore, to support real-time execution, the framework should keep the kth polling interval I(k) si less than the deadline Daj , while maximizing the other polling intervals to reduce battery power consumption of the sensor. RC aj  I(k) si = t(k+1) si ?? t(k) si  Daj Since the RT-IFTTT language supports trigger conditions with multiple sensors, an applet aj can use multiple sensing values such as si and si0 . Moreover, a sensor can be used in multiple applets. Figure 6(b) illustrates the tasks of a multi-sensor applet at a timeline. To correctly find the occurrence of an event, the framework should evaluate all the conditions while all the sensing data are fresh, so the framework polls all the sensors in an applet condition together. However, a sensor si0 may be used in another applet, and polled at a time point t(k0??1) si0 before the scheduled one t(k0) si0 . Then, the framework recalculates the next polling point t(k) si ; t(k0) si0 of sensors si ; si0 in the applet with the updated sensor value. Then, this work formulates a problem as follows. Problem Statement. The problem is to find maximum polling intervals Isi (i = 1; :::;N) for each sensor value si that satisfy the following condition. Condition. For every applet aj (j = 1; :::;M), there exists a sensor polling of a senor value si that is used in aj and satisfies I(k) si = t(k+1) si ?? t(k) si  Daj where t(k) si < tEa j < t(k+1) si . B. Algorithms The basic principle of the algorithms in the sensor polling scheduler is increasing sensor polling intervals if an event will not occur with high possibility, and decreasing the intervals when the event seems to occur soon. In other words, the algorithms reflect the probabilities of trigger conditions in an applet into the sensor polling intervals. For the example applets in Fig. 4, if the current temperature is around 0C, the algorithms do not poll the temperature data every several minutes because the probability that the temperature becomes higher than 25C in an hour is very low. In the algorithms, the next polling time of a sensor value tsi is determined by tsi   tnow + min(Im si ; Ia si ) where Im si is the next sampling interval required to keep the sensor value prediction model valid, and Ia si is the nextevaluation interval of an applet that uses the sensor value si. Each sensor value si has its maximal sampling interval Im si to build its sensor value prediction model. This work assume that a fixed value is given for Im si , and the value is much larger than relative deadlines of the applets. That is, Dj  Im si for every applet aj(j = 1; ::;M). Algorithm 1 describes the overall algorithm of the sensor polling scheduler that finds the efficient sensor polling intervals. Whenever a sensor value si is newly updated, the RTIFTTT framework invokes the algorithm because the updated value may affect the probabilities of applet conditions and their intervals. The algorithm largely consists of two steps. First, the algorithm checks if an applet aj uses the updated sensor value si. If so, the algorithm calls the CEI function that calculates the evaluation interval of the applet aj reflecting the updated value (Algorithm 2). Second, the algorithm calls the SPI function that reflects the updated evaluation intervals to all the sensors (Algorithm 3). If the sensor is not used in any updated applet, the algorithm does not update its next polling schedule. Fig. 7 briefly illustrates the cyclic process of the sensor polling scheduler. Since a trigger condition of an applet can be a combination of sub-conditions with logical operators such as && and jj, the algorithm should consider logical structures of each condition. To manage the trigger conditions in a systematic way, the RT-IFTTT framework introduces a new data structure, called condition tree. A condition tree C is a binary representation of a condition of an applet, defined as C = Internal(Cleft; lop;Cright) j Leaf(s; cop; x) where lop 2 f&&; jjg and cop 2 f<;;;>g. For example,a condition tree for App_vent in Figure 4 is defined as CApp vent = Internal(Leaf(T; >; 25);&&; Leaf(L; >; 25000)): 